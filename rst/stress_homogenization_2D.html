
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Effective Stiffness &mdash; PyMKS</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.2.0/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pymks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/pymks_logo.ico"/>
    <link rel="top" title="PyMKS" href="../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/pymks_logo.png">
          PyMKS</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="INSTALLATION.html">Installation</a></li>
                <li><a href="../EXAMPLES.html">Examples</a></li>
                <li><a href="../API.html">API</a></li>
                <li><a href="https://github.com/materialsinnovation/pymks/">Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">More <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../THEORY.html">Theory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="derivation.html">Derivation of MKS Localization Equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tech_overview.html">Technical Overview</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CREDITS.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="LICENSE.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="CITATION.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="REQUIREMENTS.html">Requirements</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="effective-stiffness">
<h1>Effective Stiffness<a class="headerlink" href="#effective-stiffness" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This example uses the MKSHomogenizationModel to create a homogenization
linkage for the effective stiffness. This example starts with a brief
background of the homogenization theory on the components of the
effective elastic stiffness tensor for a composite material. Then the
example generates random microstructures and their average stress values
that will be used to show how to calibrate and use our model. We will
also show how to use tools from
<a class="reference external" href="http://scikit-learn.org/stable/">sklearn</a> to optimize fit parameters
for the MKSHomogenizationModel. Lastly, the data is used to evaluate the
MKSHomogenizationModel for effective stiffness values for a new set of
microstructures.</p>
</div>
<div class="section" id="linear-elasticity-and-effective-elastic-modulus">
<h2>Linear Elasticity and Effective Elastic Modulus<a class="headerlink" href="#linear-elasticity-and-effective-elastic-modulus" title="Permalink to this headline">¶</a></h2>
<p>For this example we are looking to create a homogenization linkage that
predicts the effective isotropic stiffness components for two-phase
microstructures. The specific stiffness component we are looking to
predict in this example is <span class="math">\(C_{xxxx}\)</span> which is easily accessed by
applying an uniaxial macroscal strain tensor (the only non-zero
component is <span class="math">\(\varepsilon_{xx}\)</span>.</p>
<div class="math">
\[u(L, y) = u(0, y) + L\bar{\varepsilon}_{xx}\]</div>
<div class="math">
\[u(0, L) = u(0, 0) = 0\]</div>
<div class="math">
\[u(x, 0) = u(x, L)\]</div>
<p>More details about these boundary conditions can be found in [1]. Using
these boundary conditions, <span class="math">\(C_{xxxx}\)</span> can be estimated calculating
the ratio of the averaged stress over the applied averaged strain.</p>
<div class="math">
\[C_{xxxx}^* \cong  \bar{\sigma}_{xx} / \bar{\varepsilon}_{xx}\]</div>
<p>In this example, <span class="math">\(C_{xxxx}\)</span> for 6 different types of
microstructures will be estimated using the <tt class="docutils literal"><span class="pre">MKSHomogenizationModel</span></tt>
from <tt class="docutils literal"><span class="pre">pymks</span></tt>, and provides a method to compute
<span class="math">\(\bar{\sigma}_{xx}\)</span> for a new microstructure with an applied
strain of <span class="math">\(\bar{\varepsilon}_{xx}\)</span>.</p>
<div class="code python highlight-python"><div class="highlight"><pre>%matplotlib inline
%load_ext autoreload
%autoreload 2

import numpy as np
import matplotlib.pyplot as plt
</pre></div>
</div>
</div>
<div class="section" id="data-generation">
<h2>Data Generation<a class="headerlink" href="#data-generation" title="Permalink to this headline">¶</a></h2>
<p>A set of periodic microstructures and their volume averaged elastic
stress values <span class="math">\(\bar{\sigma}_{xx}\)</span> can be generated by importing
the <tt class="docutils literal"><span class="pre">make_elastic_stress_random</span></tt> function from <tt class="docutils literal"><span class="pre">pymks.datasets</span></tt>.
This function has several arguments. <tt class="docutils literal"><span class="pre">n_samples</span></tt> is the number of
samples that will be generated, <tt class="docutils literal"><span class="pre">size</span></tt> specifies the dimensions of the
microstructures, <tt class="docutils literal"><span class="pre">grain_size</span></tt> controls the effective microstructure
feature size, <tt class="docutils literal"><span class="pre">elastic_modulus</span></tt> and <tt class="docutils literal"><span class="pre">poissons_ratio</span></tt> are used to
indicate the material property for each of the phases, <tt class="docutils literal"><span class="pre">macro_strain</span></tt>
is the value of the applied uniaxixial strain, and the <tt class="docutils literal"><span class="pre">seed</span></tt> can be
used to change the the random number generator seed.</p>
<p>Let&#8217;s go ahead and create 6 different types of microstructures each with
200 samples with dimensions 21 x 21. Each of the 6 samples will have a
different microstructure feature size. The function will return and the
microstructures and their associated volume averaged stress values.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.datasets</span> <span class="kn">import</span> <span class="n">make_elastic_stress_random</span>
<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">grain_size</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="n">n_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_size</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
<span class="n">elastic_modulus</span> <span class="o">=</span> <span class="p">(</span><span class="mi">410</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">poissons_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.28</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">macro_strain</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_elastic_stress_random</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">grain_size</span><span class="o">=</span><span class="n">grain_size</span><span class="p">,</span>
                                      <span class="n">elastic_modulus</span><span class="o">=</span><span class="n">elastic_modulus</span><span class="p">,</span> <span class="n">poissons_ratio</span><span class="o">=</span><span class="n">poissons_ratio</span><span class="p">,</span>
                                      <span class="n">macro_strain</span><span class="o">=</span><span class="n">macro_strain</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The array <tt class="docutils literal"><span class="pre">X</span></tt> contains the microstructure information and has the
dimensions of <tt class="docutils literal"><span class="pre">(n_samples,</span> <span class="pre">Nx,</span> <span class="pre">Ny)</span></tt>. The array <tt class="docutils literal"><span class="pre">y</span></tt> contains the
average stress value for each of the microstructures and has dimensions
of <tt class="docutils literal"><span class="pre">(n_samples,)</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="mi">1200</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1200</span><span class="p">,)</span>
</pre></div>
</div>
<p>Lets take a look at the 6 types the microstructures to get an idea of
what they look like. We can do this by importing
<tt class="docutils literal"><span class="pre">draw_microstructures</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.tools</span> <span class="kn">import</span> <span class="n">draw_microstructures</span>
<span class="n">X_examples</span> <span class="o">=</span> <span class="n">X</span><span class="p">[::</span><span class="n">sample_size</span><span class="p">]</span>
<span class="n">draw_microstructures</span><span class="p">((</span><span class="n">X_examples</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_8_0.png" src="../_images/stress_homogenization_2D_8_0.png" />
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">draw_microstructures</span><span class="p">((</span><span class="n">X_examples</span><span class="p">[</span><span class="mi">3</span><span class="p">:]))</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_9_0.png" src="../_images/stress_homogenization_2D_9_0.png" />
<p>In this dataset 4 of the 6 microstructure types have grains that are
elongated in either the x or y directions. The remaining 2 types of
samples have equiaxed grains with different average sizes.</p>
<p>Let&#8217;s look at the stress values for each of the microstructures shown
above.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="s">&#39;Stress Values&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="p">[::</span><span class="mi">200</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Stress Values [ 0.30279774  0.27063703  0.30712908  0.29559632  0.28195039  0.28474614]
</pre></div>
</div>
<p>Now that we have a dataset to work with, we can look at how to use the
<tt class="docutils literal"><span class="pre">MKSHomogenizationModel</span></tt>to predict stress values for new
microstructures.</p>
</div>
<div class="section" id="mkshomogenizationmodel-work-flow">
<h2>MKSHomogenizationModel Work Flow<a class="headerlink" href="#mkshomogenizationmodel-work-flow" title="Permalink to this headline">¶</a></h2>
<p>The default instance of the MKSHomogenizationModel takes in a dataset
and - calculates the 2-point statistics - performs <a class="reference external" href="http://en.wikipedia.org/wiki/Dimensionality_reduction">dimensionality
reduction</a>
using <a class="reference external" href="http://en.wikipedia.org/wiki/Singular_value_decomposition">Singular Valued
Decomposition</a>
(SVD) - and fits a <a class="reference external" href="http://en.wikipedia.org/wiki/Polynomial_regression">polynomial regression
model</a> model to
the low-dimensional representation.</p>
<p>This work flow has been shown to accurately predict effective properties
in several examples [2][3], and requires that we specify the number of
components used in dimensionality reduction and the order of the
polynomial we will be using for the polynomial regression. In this
example we will show how we can use tools from
<a class="reference external" href="http://scikit-learn.org/stable/">sklearn</a> to try and optimize our
selection for these two parameters.</p>
</div>
<div class="section" id="modeling-with-mkshomogenizationmodel">
<h2>Modeling with MKSHomogenizationModel<a class="headerlink" href="#modeling-with-mkshomogenizationmodel" title="Permalink to this headline">¶</a></h2>
<p>In order to make an instance of the MKSHomogenizationModel, we need to
pass an instance of a basis (used to compute the 2-point statistics).
For this particular example, there are only 2 discrete phases, so we
will use the <tt class="docutils literal"><span class="pre">PrimitiveBasis</span></tt> from <tt class="docutils literal"><span class="pre">pymks</span></tt>. We only have two phases
denoted by 0 and 1, therefore we have two local states and our domain is
0 to 1.</p>
<p>Let&#8217;s make an instance of the MKSHomgenizationModel.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks</span> <span class="kn">import</span> <span class="n">MKSHomogenizationModel</span>
<span class="kn">from</span> <span class="nn">pymks</span> <span class="kn">import</span> <span class="n">PrimitiveBasis</span>

<span class="n">prim_basis</span> <span class="o">=</span> <span class="n">PrimitiveBasis</span><span class="p">(</span><span class="n">n_states</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">MKSHomogenizationModel</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">prim_basis</span><span class="p">,</span>
                               <span class="n">correlations</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>Let&#8217;s take a look at the default values for the number of components and
the order of the polynomial.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="s">&#39;Default Number of Components&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">n_components</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Default Polynomail Order&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Default Number of Components 2
Default Polynomail Order 1
</pre></div>
</div>
<p>These default parameters may not be the best model for a given problem,
we will now show one method that can be used to optimize them.</p>
</div>
<div class="section" id="optimizing-the-number-of-components-and-polynomial-order">
<h2>Optimizing the Number of Components and Polynomial Order<a class="headerlink" href="#optimizing-the-number-of-components-and-polynomial-order" title="Permalink to this headline">¶</a></h2>
<p>To start with, we can look at how the variance changes as a function of
the number of components. In general for SVD as well as PCA, the amount
of variance captured in each component decreases as the component number
increases. This means that as the number of components used in the
dimensionality reduction increases, the percentage of the variance will
asymptotically approach 100%. Let&#8217;s see if this is true for our dataset.</p>
<p>In order to do this we will change the number of components to 40 and
then fit the data we have using the <tt class="docutils literal"><span class="pre">fit</span></tt> function. This function
performs the dimensionality reduction and also fits the regression
model. Because our microstructures are periodic, we need to use the
<tt class="docutils literal"><span class="pre">periodic_axes</span></tt> argument when we <tt class="docutils literal"><span class="pre">fit</span></tt> the data.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">model</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">periodic_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Now look at how the cumlative variance changes as a function of the
number of components using <tt class="docutils literal"><span class="pre">draw_component_variance</span></tt> from
<tt class="docutils literal"><span class="pre">pymks.tools</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.tools</span> <span class="kn">import</span> <span class="n">draw_component_variance</span>

<span class="n">draw_component_variance</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">dimension_reducer</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_22_0.png" src="../_images/stress_homogenization_2D_22_0.png" />
<p>Roughly 90 percent of the variance is captured with the first 5
components. This means our model may only need a few components to
predict the average stress.</p>
<p>Next we need to optimize the number of components and the polynomial
order. To do this we are going to split the data into testing and
training sets. This can be done using the
<a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.cross_validation.train_test_split.html">train_test_spilt</a>
function from sklearn.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">flat_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),)</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">flat_shape</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span>
                                                    <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="mi">960</span><span class="p">,</span> <span class="mi">441</span><span class="p">)</span>
<span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">441</span><span class="p">)</span>
</pre></div>
</div>
<p>We will use cross validation with the testing data to fit a number of
models, each with a different number of components and a different
polynomial order. Then we will use the testing data to verify the best
model. This can be done using
<a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.grid_search.GridSearchCV.html">GridSeachCV</a>
from sklearn.</p>
<p>We will pass a dictionary <tt class="docutils literal"><span class="pre">params_to_tune</span></tt> with the range of
polynomial order <tt class="docutils literal"><span class="pre">degree</span></tt> and components <tt class="docutils literal"><span class="pre">n_components</span></tt> we want to
try. A dictionary <tt class="docutils literal"><span class="pre">fit_params</span></tt> can be used to pass the
<tt class="docutils literal"><span class="pre">periodic_axes</span></tt> variable to calculate periodic 2-point statistics. The
argument <tt class="docutils literal"><span class="pre">cv</span></tt> can be used to specify the number of folds used in cross
validation and <tt class="docutils literal"><span class="pre">n_jobs</span></tt> can be used to specify the number of jobs that
are ran in parallel.</p>
<p>Let&#8217;s vary <tt class="docutils literal"><span class="pre">n_components</span></tt> from 1 to 7 and <tt class="docutils literal"><span class="pre">degree</span></tt> from 1 to 3.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.grid_search</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="n">params_to_tune</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;degree&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s">&#39;n_components&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)}</span>
<span class="n">fit_params</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;size&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s">&#39;periodic_axes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]}</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params_to_tune</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
<p>The default <tt class="docutils literal"><span class="pre">score</span></tt> method for the MKSHomogenizationModel is the
<a class="reference external" href="http://en.wikipedia.org/wiki/Coefficient_of_determination">R-squared</a>
value. Let&#8217;s look at the how the mean R-squared values and their
standard deviations change as we varied the number of <tt class="docutils literal"><span class="pre">n_components</span></tt>
and <tt class="docutils literal"><span class="pre">degree</span></tt> using <tt class="docutils literal"><span class="pre">draw_gridscores_matrix</span></tt> from <tt class="docutils literal"><span class="pre">pymks.tools</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.tools</span> <span class="kn">import</span> <span class="n">draw_gridscores_matrix</span>

<span class="n">draw_gridscores_matrix</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;n_components&#39;</span><span class="p">,</span> <span class="s">&#39;degree&#39;</span><span class="p">],</span> <span class="n">score_label</span><span class="o">=</span><span class="s">&#39;R-Squared&#39;</span><span class="p">,</span>
                       <span class="n">param_labels</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Number of Components&#39;</span><span class="p">,</span> <span class="s">&#39;Order of Polynomial&#39;</span><span class="p">])</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_28_0.png" src="../_images/stress_homogenization_2D_28_0.png" />
<p>It looks like we get a poor fit when only the first and second component
are used, and when we increase the polynomial order and the components
together. The models have a high standard deviation and poor R-squared
values for both of these cases.</p>
<p>There seems to be several potential models that use 3 to 6 components.
It&#8217;s difficult to see which model is the best. Let&#8217;s use our testing
data <tt class="docutils literal"><span class="pre">X_test</span></tt> to see which model performs the best.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="s">&#39;Order of Polynomial&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Number of Components&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">best_estimator_</span><span class="o">.</span><span class="n">n_components</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;R-squared Value&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Order of Polynomial 3
Number of Components 3
R-squared Value 0.982073916104
</pre></div>
</div>
<p>For the parameter range that we searched, we have found that a model
with 3rd order polynomial and 3 components had the best R-squared value.
It&#8217;s difficult to see the differences in the score values and the
standard deviation when we have 3 or more components. Let&#8217;s take a
closer look at those values using <tt class="docutils literal"><span class="pre">draw_grid_scores</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.tools</span> <span class="kn">import</span> <span class="n">draw_gridscores</span>

<span class="n">gs_deg_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gs</span><span class="o">.</span><span class="n">grid_scores_</span> \
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;degree&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">gs_deg_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gs</span><span class="o">.</span><span class="n">grid_scores_</span> \
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;degree&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">gs_deg_3</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gs</span><span class="o">.</span><span class="n">grid_scores_</span> \
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;degree&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">draw_gridscores</span><span class="p">([</span><span class="n">gs_deg_1</span><span class="p">,</span>  <span class="n">gs_deg_2</span><span class="p">,</span> <span class="n">gs_deg_3</span><span class="p">],</span> <span class="s">&#39;n_components&#39;</span><span class="p">,</span>
                <span class="n">data_labels</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;1st Order&#39;</span><span class="p">,</span> <span class="s">&#39;2nd Order&#39;</span><span class="p">,</span> <span class="s">&#39;3rd Order&#39;</span><span class="p">],</span>
                <span class="n">colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;#f46d43&#39;</span><span class="p">,</span> <span class="s">&#39;#1a9641&#39;</span><span class="p">,</span> <span class="s">&#39;#762a83&#39;</span><span class="p">],</span>
                <span class="n">param_label</span><span class="o">=</span><span class="s">&#39;Number of Components&#39;</span><span class="p">,</span> <span class="n">score_label</span><span class="o">=</span><span class="s">&#39;R-Squared&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_32_0.png" src="../_images/stress_homogenization_2D_32_0.png" />
<p>As we said, a model with a 3rd order polynomial and 3 components will
give us the best result, but there are several other models that will
likely provide comparable results. Let&#8217;s make the best model from our
grid scores.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">best_estimator_</span>
</pre></div>
</div>
</div>
<div class="section" id="prediction-using-mkshomogenizationmodel">
<h2>Prediction using MKSHomogenizationModel<a class="headerlink" href="#prediction-using-mkshomogenizationmodel" title="Permalink to this headline">¶</a></h2>
<p>Now that we have selected values for <tt class="docutils literal"><span class="pre">n_components</span></tt> and <tt class="docutils literal"><span class="pre">degree</span></tt>,
lets fit the model with the data. Again because our microstructures are
periodic, we need to use the <tt class="docutils literal"><span class="pre">periodic_axes</span></tt> argument.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">periodic_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Let&#8217;s generate some more data that can be used to try and validate our
model&#8217;s prediction accuracy. We are going to generate 20 samples of all
six different types of microstructures using the same
<tt class="docutils literal"><span class="pre">make_elastic_stress_random</span></tt> function.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">test_sample_size</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">n_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">test_sample_size</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
<span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span> <span class="o">=</span> <span class="n">make_elastic_stress_random</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">grain_size</span><span class="o">=</span><span class="n">grain_size</span><span class="p">,</span>
                                          <span class="n">elastic_modulus</span><span class="o">=</span><span class="n">elastic_modulus</span><span class="p">,</span> <span class="n">poissons_ratio</span><span class="o">=</span><span class="n">poissons_ratio</span><span class="p">,</span>
                                          <span class="n">macro_strain</span><span class="o">=</span><span class="n">macro_strain</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let&#8217;s predict the stress values for the new microstructures.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">y_predict</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">periodic_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>We can look to see if the low-dimensional representation of the new data
is similar to the low-dimensional representation of the data we used to
fit the model using <tt class="docutils literal"><span class="pre">draw_components</span></tt> from <tt class="docutils literal"><span class="pre">pymks.tools</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.tools</span> <span class="kn">import</span> <span class="n">draw_components</span>

<span class="n">draw_components</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_data</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_data</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">label1</span><span class="o">=</span><span class="s">&#39;Training Data&#39;</span><span class="p">,</span> <span class="n">label2</span><span class="o">=</span><span class="s">&#39;Testing Data&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_42_0.png" src="../_images/stress_homogenization_2D_42_0.png" />
<p>The predicted data seems to be reasonably similar to the data we used to
fit the model with. Now let&#8217;s look at the score value for the predicted
data.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">r2_score</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;R-squared&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">,</span> <span class="n">periodic_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>R-squared 0.99834842402
</pre></div>
</div>
<p>Looks pretty good. Let&#8217;s print out one actual and predicted stress value
for each of the 6 microstructure types to see how they compare.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">print</span><span class="p">(</span><span class="s">&#39;Actual Stress   &#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">y_new</span><span class="p">[::</span><span class="mi">20</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Predicted Stress&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">y_predict</span><span class="p">[::</span><span class="mi">20</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Actual Stress    [ 0.28985647  0.2831434   0.25138814  0.29399186  0.26338502  0.27548337]
Predicted Stress [ 0.29038894  0.28375754  0.25230674  0.29388488  0.26327469  0.27586485]
</pre></div>
</div>
<p>Lastly, we can also evaluate our prediction by looking at a
goodness-of-fit plot. We can do this by importing
<tt class="docutils literal"><span class="pre">draw_goodness_of_fit</span></tt> from <tt class="docutils literal"><span class="pre">pymks.tools</span></tt>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymks.tools</span> <span class="kn">import</span> <span class="n">draw_goodness_of_fit</span>

<span class="n">fit_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">periodic_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])])</span>
<span class="n">pred_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_new</span><span class="p">,</span> <span class="n">y_predict</span><span class="p">])</span>
<span class="n">draw_goodness_of_fit</span><span class="p">(</span><span class="n">fit_data</span><span class="p">,</span> <span class="n">pred_data</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Training Data&#39;</span><span class="p">,</span> <span class="s">&#39;Testing Data&#39;</span><span class="p">])</span>
</pre></div>
</div>
<img alt="../_images/stress_homogenization_2D_48_0.png" src="../_images/stress_homogenization_2D_48_0.png" />
<p>We can see that the MKSHomogenizationModel has created a homogenization
linkage for the effective stiffness for the 6 different microstructures
and has predicted the average stress values for our new microstructures
reasonably well.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>[1] Landi, G., S.R. Niezgoda, S.R. Kalidindi, Multi-scale modeling of
elastic response of three-dimensional voxel-based microstructure
datasets using novel DFT-based knowledge systems. Acta Materialia, 2009.
58 (7): p. 2716-2725
<a class="reference external" href="http://dx.doi.org/10.1016/j.actamat.2010.01.007">doi:10.1016/j.actamat.2010.01.007</a>.</p>
<p>[2] Çeçen, A., et al. &#8220;A data-driven approach to establishing
microstructure–property relationships in porous transport layers of
polymer electrolyte fuel cells.&#8221; Journal of Power Sources 245 (2014):
144-153.
<a class="reference external" href="http://dx.doi.org/10.1016/j.jpowsour.2013.06.100">doi:10.1016/j.jpowsour.2013.06.100</a></p>
<p>[3] Deshpande, P. D., et al. &#8220;Application of Statistical and Machine
Learning Techniques for Correlating Properties to Composition and
Manufacturing Processes of Steels.&#8221; 2 World Congress on Integrated
Computational Materials Engineering. John Wiley &amp; Sons, Inc.
<a class="reference external" href="http://dx.doi.org/10.1002/9781118767061.ch25">doi:10.1002/9781118767061.ch25</a></p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>